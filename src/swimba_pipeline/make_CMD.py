import argparse
from dataclasses import dataclass
from pathlib import Path

import joblib
import h5py
import MAS_library as MASL
import numpy as np
from scipy.spatial import KDTree


@dataclass(slots=True, kw_only=True)
class SnapshotData:
    gas_position: np.ndarray  # Mpc / h
    gas_velocity: np.ndarray  # km / s
    gas_mass: np.ndarray  # h Msun / Mpc^2
    gas_temperature: np.ndarray  # K
    gas_pressure: np.ndarray  # h^2 Msun (km / s)^2 / kpc^3
    gas_metallicity: np.ndarray  # dimensionless
    gas_neutral_H: np.ndarray  # h Msun / Mpc^2
    gas_electron_density: np.ndarray  # h^3 / cm^3 / Mpc
    gas_radius: np.ndarray  # Mpc / h
    gas_magnesium: np.ndarray  # dimensionless
    gas_iron: np.ndarray  # dimensionless

    dm_position: np.ndarray  # Mpc / h
    dm_mass: np.ndarray  # h Msun / Mpc^2
    dm_velocity: np.ndarray  # km / s
    dm_radius: np.ndarray  # Mpc / h

    star_position: np.ndarray  # Mpc / h
    star_mass: np.ndarray  # h Msun / Mpc^2
    star_radius: np.ndarray  # Mpc / h

    bh_position: np.ndarray  # Mpc / h
    bh_mass: np.ndarray  # Mpc / h
    bh_radius: np.ndarray  # Mpc / h

    box_size: float  # Mpc / h
    redshift: float


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "snapshots",
        nargs="+",
        help="A gadget-hdf5 format snapshot(s) which will be imaged.",
        type=Path,
    )
    parser.add_argument("--target", type=Path, default=Path.cwd())
    parser.add_argument(
        "-p",
        "--parallel",
        help="How many parallel tasks to run.",
        type=int,
        default=joblib.cpu_count(),
    )
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("--grid", type=int, default=256)
    parser.add_argument("--r-divisions", type=int, default=20)
    parser.add_argument("--tracers", type=int, default=1000)
    parser.add_argument("--splits", type=int, default=5)

    args = parser.parse_args()
    snaps: list[Path] = args.snapshots
    target_dir: Path = args.target
    parallelism: int = args.parallel
    verbose: bool = args.verbose
    grid: int = args.grid
    r_divisions: int = args.r_divisions
    tracers: int = args.tracers
    splits: int = args.splits

    n_jobs = min(parallelism, 3 * splits * len(snaps))
    results: list[dict[str, np.ndarray]] = joblib.parallel.Parallel(
        n_jobs=n_jobs,
        verbose=int(verbose) * 10,
        return_as="generator",
        pre_dispatch="1.5*n_jobs"
    )(
        joblib.parallel.delayed(make_images)(
            axis,
            snap.box_size * slice / splits,
            snap.box_size * (slice + 1) / splits,
            snap,
            verbose=verbose,
            grid=grid,
            r_divisions=r_divisions,
            tracers=tracers,
        )
        for snap in map(lambda s: load_snap(s, parallelism), snaps)
        for axis in range(3)
        for slice in range(splits)
    )  # type: ignore

    target_dir.mkdir(parents=True, exist_ok=True)
    fields = [
        "Mgas",
        "Vgas",
        "Mcdm",
        "Vcdm",
        "Mstar",
        "Mtot",
        "T",
        "Z",
        "P",
        "HI",
        "ne",
        "MgFe",
    ]

    for snap in snaps:
        full_results = {
            field: np.empty((3 * splits, grid, grid), dtype=np.float64)
            for field in fields
        }
        z = 0
        for i in range(3 * splits):
            result = next(results)
            for f in fields:
                full_results[f][i] = result[f]
            z = result["z"]

        # This does not include the code name or the set name.
        # Those should be added in post when combining images together.
        suffix = f"z={z:.2f}.npy"
        paths = {field: target_dir / f"Maps_{field}_{suffix}" for field in fields}

        for field, path in paths.items():
            np.save(path, full_results[field])


def make_images(
    axis: int,
    pos_min: float,
    pos_max: float,
    data: SnapshotData,
    *,
    verbose: bool = False,
    grid: int = 256,
    r_divisions: int = 20,
    tracers: int = 1000,
):
    axis_coord = data.gas_position[:, axis]
    indices_gas = np.nonzero((axis_coord >= pos_min) & (axis_coord < pos_max))[0]
    axis_coord = data.dm_position[:, axis]
    indices_dm = np.nonzero((axis_coord >= pos_min) & (axis_coord < pos_max))[0]
    axis_coord = data.star_position[:, axis]
    indices_star = np.nonzero((axis_coord >= pos_min) & (axis_coord < pos_max))[0]
    axis_coord = data.bh_position[:, axis]
    indices_bh = np.nonzero((axis_coord >= pos_min) & (axis_coord < pos_max))[0]

    axis_x = (axis + 1) % 3
    axis_y = (axis + 2) % 3

    masked_data = SnapshotData(
        gas_position=data.gas_position[:, [axis_x, axis_y]][indices_gas],
        gas_velocity=data.gas_velocity[indices_gas],
        gas_mass=data.gas_mass[indices_gas],
        gas_temperature=data.gas_temperature[indices_gas],
        gas_pressure=data.gas_pressure[indices_gas],
        gas_metallicity=data.gas_metallicity[indices_gas],
        gas_neutral_H=data.gas_neutral_H[indices_gas],
        gas_electron_density=data.gas_electron_density[indices_gas],
        gas_radius=data.gas_radius[indices_gas],
        gas_magnesium=data.gas_magnesium[indices_gas],
        gas_iron=data.gas_iron[indices_gas],
        dm_position=data.dm_position[:, [axis_x, axis_y]][indices_dm],
        dm_mass=data.dm_mass[indices_dm],
        dm_velocity=data.dm_velocity[indices_dm],
        dm_radius=data.dm_radius[indices_dm],
        star_position=data.star_position[:, [axis_x, axis_y]][indices_star],
        star_mass=data.star_mass[indices_star],
        star_radius=data.star_radius[indices_star],
        bh_position=data.bh_position[:, [axis_x, axis_y]][indices_bh],
        bh_mass=data.bh_mass[indices_bh],
        bh_radius=data.bh_radius[indices_bh],
        box_size=data.box_size,
        redshift=data.redshift,
    )

    box_size = masked_data.box_size

    fields = {
        "T": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_temperature * masked_data.gas_mass,
        ),
        "Z": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_metallicity * masked_data.gas_mass,
        ),
        "Vgas": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_velocity * masked_data.gas_mass,
        ),
        "P": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_pressure * masked_data.gas_mass,
        ),
        "Mgas": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_mass,
        ),
        "Mcdm": (
            masked_data.dm_position,
            masked_data.dm_radius,
            masked_data.dm_mass,
        ),
        "Vcdm": (
            masked_data.dm_position,
            masked_data.dm_radius,
            masked_data.dm_velocity * masked_data.dm_mass,
        ),
        "Mstar": (
            masked_data.star_position,
            masked_data.star_radius,
            masked_data.star_mass,
        ),
        "HI": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_neutral_H,
        ),
        "ne": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_electron_density,
        ),
        "Mg": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_magnesium,
        ),
        "Fe": (
            masked_data.gas_position,
            masked_data.gas_radius,
            masked_data.gas_iron,
        ),
    }

    results = {}
    for name, (position, radii, field) in fields.items():
        out = np.zeros((grid, grid), dtype=np.float64)
        MASL.projected_voronoi(
            out,
            position,
            field,
            radii,
            0.0,
            0.0,
            box_size,
            tracers,
            r_divisions,
            True,  # periodic
            verbose,
        )
        results[name] = out

    m_total = np.zeros((grid, grid), dtype=np.float64)
    for pos, mass, radii in [
        (masked_data.gas_position, masked_data.gas_mass, masked_data.gas_radius),
        (masked_data.dm_position, masked_data.dm_mass, masked_data.dm_radius),
        (masked_data.star_position, masked_data.star_mass, masked_data.star_radius),
        (masked_data.bh_position, masked_data.bh_mass, masked_data.bh_radius),
    ]:
        MASL.projected_voronoi(
            m_total,
            pos,
            mass,
            radii,
            0.0,
            0.0,
            box_size,
            tracers,
            r_divisions,
            True,
            verbose,
        )
    results["Mtot"] = m_total

    results["MgFe"] = results.pop("Mg") / results.pop("Fe")

    for k in ["T", "Z", "P", "Vgas", "MgFe"]:
        zero_mass = results["Mgas"] == 0.0
        np.divide(
            results[k],
            results["Mgas"],
            where=~zero_mass,
            out=results[k],
        )
        results[k][zero_mass] = 0.0

    for k in ["Vcdm"]:
        zero_mass = results["Mcdm"] == 0.0
        np.divide(
            results[k],
            results["Mcdm"],
            where=~zero_mass,
            out=results[k],
        )
        results[k][zero_mass] = 0.0

    area = (box_size / grid) ** 2
    for k in ["Mgas", "Mcdm", "Mstar", "Mtot", "HI", "ne"]:
        results[k] /= area

    results["z"] = data.redshift
    return results


def load_snap(snap: Path, parallelism: int) -> SnapshotData:
    """
    Assumes gadget units
    """
    with h5py.File(snap) as f:
        redshift = f["Header"].attrs["Redshift"]

        gas_position = f["PartType0/Coordinates"][:] / 1000  # Mpc / h
        dm_position = f["PartType1/Coordinates"][:] / 1000  # Mpc / h
        star_position = f["PartType4/Coordinates"][:] / 1000  # Mpc / h
        bh_position = f["PartType5/Coordinates"][:] / 1000  # Mpc / h

        gas_velocity = np.linalg.norm(f["PartType0/Velocities"][:], axis=1) / np.sqrt(
            1.0 + redshift
        )  # km / s
        dm_velocity = np.linalg.norm(f["PartType1/Velocities"][:], axis=1) / np.sqrt(
            1.0 + redshift
        )  # km / s

        gas_mass = f["PartType0/Masses"][:] * 1e10  # Msun / h
        dm_mass = f["PartType1/Masses"][:] * 1e10  # Msun / h
        star_mass = f["PartType4/Masses"][:] * 1e10  # Msun / h
        bh_mass = f["PartType5/Masses"][:] * 1e10  # Msun / h

        gas_radius = get_radii(gas_position, parallelism)
        dm_radius = get_radii(dm_position, parallelism)
        star_radius = np.zeros(star_position.shape[0], dtype=np.float32)
        bh_radius = np.zeros(bh_position.shape[0], dtype=np.float32)
        # star_radius = get_radii(star_position, parallelism)
        # bh_radius = get_radii(bh_position, parallelism)

        gas_metallicity = f["PartType0/Metallicity"][:, 0] + 8e-10  # dimensionless
        gas_hI = f["PartType0/NeutralHydrogenAbundance"][:] * gas_mass  # Msun / h
        gas_electron = f["PartType0/ElectronAbundance"][:]

        gas_rho = f["PartType0/Density"][:]
        gas_u = f["PartType0/InternalEnergy"][:]
        gamma = 5.0 / 3.0
        gas_pressure = (gamma - 1) * gas_u * gas_rho * 1e10

        if "Temperatures" in f["PartType0"]:
            gas_temperature = f["PartType0/Temperatures"][:]
        else:
            yhelium = 0.0789
            T = (
                gas_u
                * (1.0 + 4.0 * yhelium)
                / (1.0 + yhelium + gas_electron)
                * 1e10
                * (2.0 / 3.0)
            )
            BOLTZMANN = 1.38065e-16  # erg/K - NIST 2010
            PROTONMASS = 1.67262178e-24  # gram  - NIST 2010
            T *= PROTONMASS / BOLTZMANN

        gas_magnesium = (f["PartType0/Metallicity"][:, 6] + 1e-10) * gas_mass
        gas_iron = (f["PartType0/Metallicity"][:, 8] + 1e-10) * gas_mass

        box_size = f["Header"].attrs["BoxSize"] / 1000

        return SnapshotData(
            gas_position=gas_position.astype(np.float32, copy=False),
            gas_velocity=gas_velocity.astype(np.float32, copy=False),
            gas_mass=gas_mass.astype(np.float32, copy=False),
            gas_radius=gas_radius.astype(np.float32, copy=False),
            gas_metallicity=gas_metallicity.astype(np.float32, copy=False),
            gas_neutral_H=gas_hI.astype(np.float32, copy=False),
            gas_electron_density=gas_electron.astype(np.float32, copy=False),
            gas_temperature=gas_temperature.astype(np.float32, copy=False),
            gas_pressure=gas_pressure.astype(np.float32, copy=False),
            gas_magnesium=gas_magnesium.astype(np.float32, copy=False),
            gas_iron=gas_iron.astype(np.float32, copy=False),
            dm_position=dm_position.astype(np.float32, copy=False),
            dm_velocity=dm_velocity.astype(np.float32, copy=False),
            dm_mass=dm_mass.astype(np.float32, copy=False),
            dm_radius=dm_radius.astype(np.float32, copy=False),
            star_position=star_position.astype(np.float32, copy=False),
            star_mass=star_mass.astype(np.float32, copy=False),
            star_radius=star_radius.astype(np.float32, copy=False),
            bh_position=bh_position.astype(np.float32, copy=False),
            bh_mass=bh_mass.astype(np.float32, copy=False),
            bh_radius=bh_radius.astype(np.float32, copy=False),
            box_size=box_size,
            redshift=redshift,
        )


def get_radii(positions, parallelism):
    positions %= 25
    tree = KDTree(positions, boxsize=25)
    return tree.query(positions, 32 + 1, workers=parallelism)[0][:, -1]


if __name__ == "__main__":
    main()
